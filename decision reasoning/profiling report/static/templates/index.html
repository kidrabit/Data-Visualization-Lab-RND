<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <style>   
  .axis path,
  .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
  }

  .point {
    fill: steelblue;
    stroke: #000;
  }  

   .node {
      cursor: pointer;
   }

   .node circle {
     fill: #fff;
     stroke: steelblue;
     stroke-width: 3px;
   }

   .node text {
     font: 12px sans-serif;
   }

   .link {
     fill: none;
     stroke: #ccc;
     stroke-width: 2px;
   }

   .vis {
     display: flex;
   }

   #tree, #scatter, #box {
     flex: 1;
   }
    </style>
  </head>
  <!-- load the d3.js library -->   
  <script src="https://d3js.org/d3.v4.js"></script>
  <script>
    d3v4 = d3;
    window.d3 = null;
  </script>
  <script src="https://d3js.org/d3.v3.js"></script>
  <script>
    d3v3 = d3;
    window.d3 = null;
  </script>
  <body>
    <div class="vis">
      <div id="tree"></div>
      <div id="scatter"></div>
      <div id="box"></div>
    </div>
  </body>

<script>
var treeData = [
  {
    "file": "root", 
    "name": "50",
    "parent": "null",
    "children": [
      {
        "file": "1.1",
        "name": "26",
        "children": [
          {"file": "2.1", "name": "12"},
          {
            "file": "2.2",
            "name": "12",
            "children": [
              {"file": "3.1", "name": "0"},
              {"file": "3.2", "name": "0"},
              {"file": "3.3", "name": "0"}  
            ]
          },
          {
            "file": "2.3",
            "name": "12"
          }
        ]
      },
      {
        "file": "1.2",
        "name": "38",
      },
      {
        "file": "1.3",
        "name": "38",
      }      
    ]
  }
];

// ************** Generate the tree diagram *****************
var margin = {top: 50, right: 50, bottom: 50, left: 50},
   width = 500 - margin.right - margin.left,
   height = 500 - margin.top - margin.bottom;
   
var i = 0,
   duration = 750,
   root;

var tree = d3v3.layout.tree()
   .size([height, width]);

var diagonal = d3v3.svg.diagonal()
   .projection(function(d) { return [d.x, d.y]; });

var svg = d3v3.select("#tree").append("svg")
   .attr("width", width + margin.right + margin.left)
   .attr("height", height + margin.top + margin.bottom)
   .append("g")
   .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

root = treeData[0];
root.x0 = height / 2;
root.y0 = 0;
  
update(root);

d3v3.select(self.frameElement).style("height", "500px");

function update(source) {
  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse(),
     links = tree.links(nodes);

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 130; });

  // Update the nodes…
  var node = svg.selectAll("g.node")
     .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("g")
     .attr("class", "node")
     .attr("transform", function(d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })
     .on("click", click)
     .on("auxclick", auxclick);

  nodeEnter.append("circle")
     .attr("r", 1e-6)
     .style("fill", function(d) { return "#fff"; });

  nodeEnter.append("text")
     .attr("x", function(d) { return d.children || d._children ? -13 : 13; })
     .attr("dy", ".35em")
     .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
     .text(function(d) { return d.name; })
     .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
     .duration(duration)
     .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  nodeUpdate.select("circle")
     .attr("r", 10)
     .style("fill", function(d) { return "#fff"; });

  nodeUpdate.select("text")
     .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
     .duration(duration)
     .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
     .remove();

  nodeExit.select("circle")
     .attr("r", 1e-6);

  nodeExit.select("text")
     .style("fill-opacity", 1e-6);

  // Update the links…
  var link = svg.selectAll("path.link")
     .data(links, function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("path", "g")
     .attr("class", "link")
     .attr("d", function(d) {
      var o = {x: source.x0, y: source.y0};
      return diagonal({source: o, target: o});
     });

  // Transition links to their new position.
  link.transition()
     .duration(duration)
     .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
     .duration(duration)
     .attr("d", function(d) {
      var o = {x: source.x, y: source.y};
      return diagonal({source: o, target: o});
     })
     .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
   d.x0 = d.x;
   d.y0 = d.y;
  });
}

function auxclick(d) {
  tree(d);
}

function click(d) {
  scatter(d);
  box(d);
}

// Toggle children on click.
function tree(d) {
  if (d.children) {
   d._children = d.children;
   d.children = null;
  } else {
   d.children = d._children;
   d._children = null;
  }
  update(d);
}

// ************** Generate the scatter plot *****************
function scatter(d) {
  var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 500 - margin.right - margin.left,
    height = 400 - margin.top - margin.bottom;

  var x = d3v3.scale.linear()
      .range([0, width]);

  var y = d3v3.scale.linear()
      .range([height, 0]);

  var svg = d3v3.select("#scatter").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var file = "static/" + d.file + ".csv";
  d3v3.csv(file, function(error, data) {
    if (error) throw error;

    // Coerce the strings to numbers.
    data.forEach(function(d) {
      d.pm10 = +d.pm10;
      d.pm25 = +d.pm25;
      d.temp = +d.temp;
      d.humi = +d.humi;
    });

    // Compute the scales’ domains.
    x.domain(d3v3.extent(data, function(d) { return d.temp; })).nice();
    y.domain(d3v3.extent(data, function(d) { return d.humi; })).nice();

    // Add the x-axis.
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3v3.svg.axis().scale(x).orient("bottom"));

    // Add the y-axis.
    svg.append("g")
        .attr("class", "y axis")
        .call(d3v3.svg.axis().scale(y).orient("left"));

    // Add the points!
    svg.selectAll(".point")
        .data(data)
        .enter()
        .append("path")
        .attr("class", "point")
        .attr("d", d3v3.svg.symbol().type("circle"))
        .style("fill", function(d){
          if(d.temp == 0 || d.humi == 0){return "red";}
          else{return "lightsteelblue";}
        })
        .attr("transform", function(d) { return "translate(" + x(d.temp) + "," + y(d.humi) + ")"; });
  });
}

function box(d) {
  // set the dimensions and margins of the graph
  var margin = {top: 10, right: 30, bottom: 30, left: 40},
      width = 500 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;

  // append the svg object to the body of the page
  var svg = d3v4.select("#box")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

  //var file = "static/" + d.file + "_transpose.csv";
  // Read the data and compute summary statistics for each specie
  d3v4.csv("static/3.3_transpose.csv", function(data) {
    // Compute quartiles, median, inter quantile range min and max --> these info are then used to draw the box.
    var sumstat = d3v4.nest() // nest function allows to group the calculation per level of a factor
      .key(function(d) { return d.Species;})
      .rollup(function(d) {
        q1 = d3v4.quantile(d.map(function(g) { return g.Sepal_Length;}).sort(d3v4.ascending),.25)
        median = d3v4.quantile(d.map(function(g) { return g.Sepal_Length;}).sort(d3v4.ascending),.5)
        q3 = d3v4.quantile(d.map(function(g) { return g.Sepal_Length;}).sort(d3v4.ascending),.75)
        interQuantileRange = q3 - q1
        min = q1 - 1.5 * interQuantileRange
        max = q3 + 1.5 * interQuantileRange
        return({q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max})
      })
      .entries(data)

    // Show the X scale
    var x = d3v4.scaleBand()
      .range([0, width])
      .domain(["pm10", "pm25", "humi"])
      .paddingInner(1)
      .paddingOuter(.5)
    svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3v4.axisBottom(x))

    // Show the Y scale
    var y = d3v4.scaleLinear()
      .domain([0,80])
      .range([height, 0])
    svg.append("g").call(d3v4.axisLeft(y))

    // Show the main vertical line
    svg
      .selectAll("vertLines")
      .data(sumstat)
      .enter()
      .append("line")
        .attr("x1", function(d){return(x(d.key))})
        .attr("x2", function(d){return(x(d.key))})
        .attr("y1", function(d){return(y(d.value.min))})
        .attr("y2", function(d){return(y(d.value.max))})
        .attr("stroke", "black")
        .style("width", 40)

    // rectangle for the main box
    var boxWidth = 100
    svg
      .selectAll("boxes")
      .data(sumstat)
      .enter()
      .append("rect")
          .attr("x", function(d){return(x(d.key)-boxWidth/2)})
          .attr("y", function(d){return(y(d.value.q3))})
          .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
          .attr("width", boxWidth )
          .attr("stroke", "black")
          .style("fill", "#69b3a2")

    // Show the median
    svg
      .selectAll("medianLines")
      .data(sumstat)
      .enter()
      .append("line")
        .attr("x1", function(d){return(x(d.key)-boxWidth/2) })
        .attr("x2", function(d){return(x(d.key)+boxWidth/2) })
        .attr("y1", function(d){return(y(d.value.median))})
        .attr("y2", function(d){return(y(d.value.median))})
        .attr("stroke", "black")
        .style("width", 80)
  })
}

/*
// ************** Generate the density plot *****************
function density(d) {
  var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 450 - margin.right - margin.left,
    height = 350 - margin.top - margin.bottom;

  var svg = d3v4.select("#density")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

  // get the data
  d3v4.csv("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/data_doubleHist.csv", function(data) {

    // add the x Axis
    var x = d3v4.scaleLinear()
        .domain([-10,15])
        .range([0, width]);
    svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3v4.axisBottom(x));

    // add the y Axis
    var y = d3v4.scaleLinear()
              .range([height, 0])
              .domain([0, 0.10]);
    svg.append("g")
        .call(d3v4.axisLeft(y));

    // Compute kernel density estimation
    var kde = kernelDensityEstimator(kernelEpanechnikov(7), x.ticks(60))
    var density1 =  kde( data
        .filter( function(d){return d.type === "variable 1"} )
        .map(function(d){  return d.value; }) )
    var density2 =  kde( data
        .filter( function(d){return d.type === "variable 2"} )
        .map(function(d){  return d.value; }) )

    // Plot the area
    svg.append("path")
        .attr("class", "mypath")
        .datum(density1)
        .attr("fill", "#69b3a2")
        .attr("opacity", ".6")
        .attr("stroke", "#000")
        .attr("stroke-width", 1)
        .attr("stroke-linejoin", "round")
        .attr("d",  d3v4.line()
          .curve(d3v4.curveBasis)
            .x(function(d) { return x(d[0]); })
            .y(function(d) { return y(d[1]); })
        );

    // Plot the area
    svg.append("path")
        .attr("class", "mypath")
        .datum(density2)
        .attr("fill", "#404080")
        .attr("opacity", ".6")
        .attr("stroke", "#000")
        .attr("stroke-width", 1)
        .attr("stroke-linejoin", "round")
        .attr("d",  d3v4.line()
          .curve(d3v4.curveBasis)
            .x(function(d) { return x(d[0]); })
            .y(function(d) { return y(d[1]); })
        );

  });

  // Handmade legend
  svg.append("circle").attr("cx",300).attr("cy",30).attr("r", 6).style("fill", "#69b3a2")
  svg.append("circle").attr("cx",300).attr("cy",60).attr("r", 6).style("fill", "#404080")
  svg.append("text").attr("x", 320).attr("y", 30).text("before").style("font-size", "15px").attr("alignment-baseline","middle")
  svg.append("text").attr("x", 320).attr("y", 60).text("current").style("font-size", "15px").attr("alignment-baseline","middle")

  // Function to compute density
  function kernelDensityEstimator(kernel, X) {
    return function(V) {
      return X.map(function(x) {
        return [x, d3v4.mean(V, function(v) { return kernel(x - v); })];
      });
    };
  }
  function kernelEpanechnikov(k) {
    return function(v) {
      return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
    };
  }
}
*/
</script>
  </body>
</html>